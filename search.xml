<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[STM32CubeMX的编码器接口]]></title>
    <url>%2F2019%2F04%2F25%2FSTM32CubeMX%E7%9A%84%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[编码器是将位移或者角度转换为电信号的仪器，按照读出方式编码器可以分为接触式和非接触式两种；按照工作原理可分为增量式和绝对式两种。增量式编码器是将位移转换成周期性的电信号，再把这个电信号转变为计数脉冲，用脉冲的个数表示位移的大小。绝对式编码器的每一个位置对应一个确定的数字码，因此它的示值只与测量的起始和终止位置有关，而与测量的中间过程无关。由于绝对式编码器是直接去读位置，所以其位置信息是通过通讯的方式进行读取，相对增量式编码器使用更加简单（通常价格也更加昂贵，且通常情况下量程较短，类似于光栅尺的低阶版）。所以在使用中我们更多的关注点在如何精确读取增量式编码器的值。首先我们应该知道，一般增量式编码器的输出有集电极开路输出，推拉输出以及线驱动输出。输出信号类型目前一般都是正交信号AB相输出加上参考零位信号Z相输出的方式。当然也有更少的只有A相或者AB相输出和更多的A，\overline{A}，B，\overline{B}，Z，\overline{Z}输出，A，\overline{A}为互补的一组信号。其中A、B为相差90°的脉冲，Z相信号在编码器旋转一周发出一个脉冲信号，通常用作参考零位。通常我们通过判定AB相信号的前后位置来判定编码器正转和反转。 了解了增量式编码器的工作原理，接下来我们看看应该如何是该它。STM32给我们预留了该增量式编码器的硬件接口。通过STM32CubeMX对gpio进行配置后，将增量式编码器的AB两相信号接到STM32的对应IO口上，当编码器工作时，STM32会硬件记录编码器的信号值，此时编码器正转或者反转，STM32会自己进行硬件加减运算，使用方便且精度高，记录也很精确。这里我们使用的MCU是STM32F103RCT6，编码器为光洋电子的TRD-2T，两相+原点增量式旋转编码器 STM32的编码器接口模式基本上相当于使用了一个带有方向选择的外部时钟这里我们使用TIM3。首先我们使用CubeMX配置PA6和PA7的功能为TIM3_CH1和TIM3_CH2,然后配置TIM3为编码器接口模式。 由于STM32的编码器接口计数方式为上升沿和下降沿都要计数，所以对于AB两相信号为方波来说其编码器的值为实际值的4倍，故PSC配置为4-1，其他的主要配置清单如图： 同时建议使用中断方式读取处理编码器，所以我们打开TIM3的全局中断： 以上就是CubeMX上对编码器接口的配置，接下来我们生成MDK-ARM工程，用keil打开，在main函数中使用以下函数对编码器寄存器值清零：1__HAL_TIM_SET_COUNTER(&amp;htim3,0); 然后打开定时器的encoder模式（查询或中断模式）：12HAL_TIM_Encoder_Start(&amp;htim3, TIM_CHANNEL_ALL); //打开定时器的encoder模式HAL_TIM_Encoder_Start_IT(&amp;htim3, TIM_CHANNEL_ALL); //打开定时器的encoder中断模式 如果使用查询模式，则直接使用：1encoder_cnt = (uint32_t)(__HAL_TIM_GET_COUNTER(&amp;htim3));//获取定时器的值 即可获取当前编码器的值。如果使用中断方式，则编码器每给一个信号，STM32就会进入编码器定时器中断，可在该中断中控制电机，使控制更加精确，灵敏。中断函数为：123456789void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)&#123; if(htim -&gt;Instance == htim3.Instance) &#123; encoder_cnt = (uint32_t)(__HAL_TIM_GET_COUNTER(&amp;htim3)); ··· &#125; ···&#125; 在控制中我们还可以将Z相接入外部中断，对编码器做零位处理，使得获取到的编码器值更加准确。]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>编码器</tag>
        <tag>CubeMX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中兴众星捧月算法大赛]]></title>
    <url>%2F2019%2F04%2F25%2F%E4%B8%AD%E5%85%B4%E4%BC%97%E6%98%9F%E6%8D%A7%E6%9C%88%E7%AE%97%E6%B3%95%E5%A4%A7%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[在本次算法大赛中，我使用的是最简单的匹配方法，对报文原数据进行匹配，使用C的标准输入输出，赛题判定通过牛客网在线判定系统，对生成的T对数和匹配结果进行判定分数（此题判定方法存在bug，最终中兴专家会分析代码结合算法思路文档对答题正确与否进行判定）。虽然我的算法是最笨的方法，不过我已经反复测试验算，将本方法能优化到的地方进行了优化，应该是完全涵盖了所有的数据测试结果。最后我会附上源码，如有误欢迎指正！ 赛题解读T在网络通信领域应用中自然也不会缺席，并且网络专家们提供了极其简单的方法来操控T。相比传统的内存往其地址上写0和1组成的data（数据），我们只要再加一个mask（掩码）便能显现T的特性。例如我们写一个data:0b00000010和一个mask:0b11111110（data、mask bits一一对应），它表示的数就是（result）：12340 b 0 0 0 0 0 0 1 0（data）0 b 1 1 1 1 1 1 1 0（mask）--------------------------------0 b 0 0 0 0 0 0 1 *（result） 也就是说mask中bit为1，result相应bit维持data原值；mask中bit为0，不管data相应bit原来是0还是1，result相应bit就为；反过来，如果bit要写0或者1，就置data bit为0或者1，mask为1，如果bit既要表示0又要表示1就置mask相应bit为0。示例中因为即可以表示0又可以表示1，所以我们实际写进去的result就表示了2（0b00000010）和3（0b00000011）两个数。操控So easy!很快专家们发现这个属性非常适合用于网络通信中的报文分类，所谓报文分类就是指给定一些规则和报文，找出每个报文各属于哪个规则，规则中指定了几个字段的值和匹配的规则，本质上就是数值的比较，常见的匹配规则有： 前缀匹配：仅前缀部分相同 精确匹配：每位都必须相同 范围匹配：字段值必须在一个范围之内 IPv4地址（32bits)为前缀匹配如：格式1.1.1.0/24表示如果报文的IP跟规则的前24bits相同就算匹配，在T中可以表示为data:0x01010100，mask:0xffffff00即后8bits任意。协议号（8bits)为精确匹配如：格式0x11/0xff表示每位都必须相同，在T中可以表示为data:0x11，mask:0xff即每个bits都关心。 赛题内容对由五元组即目的IPv4地址、源IPv4地址、目的端口、源端口、协议5个字段以及结果组成的规则进行处理得到满足T属性的数据；给定报文进行正确的分类，找到报文匹配的规则对应的结果。标准输入包含了多个规则（包括规则对应的结果）以及多个报文，具体格式见后面的说明，程序需要实现的功能：1.读取标准输入中的规则部分，生成满足T属性的数据并输出到标准输出。2.读取标准输入中的报文部分，使用1中的输出数据（存放在内存中的数据）进行分类，找到匹配的条目对应的结果输出到标准输出。特别说明1）2中报文跟T中的data、mask条目匹配是指报文的每个bit跟条目中的每个bit都匹配，单个bit匹配规则如下： mask bit data bit pkt bit match result（1匹配，0不匹配） 0 0或者1 0或者1 1 1 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 2）跟T中的data、mask条目进行匹配的数据无需为读取的原始报文。3）不同data、mask对是独立的，不能关联使用。4）规则中IP的前缀长度为8到32，端口为0到65535，协议为0到255，算法需要适应此范围的任何数据。5）规则的每个字段只能单独处理，2中不能根据原始规则数据进行分类。 程序输入输出1) 输入格式：输入分为两个部分，第一部分为规则，第二部分为报文。第一行为总的规则数，从第二行开始为具体的规则，每行包含目的IP、源IP、目的端口、源端口、协议以及结果共6个信息，各个字段之间用空格分隔。规则部分后面为报文部分，报文部分第一行为总的报文数，后面每一行是报文信息，包含目的IP、源IP、目的端口、源端口、协议共5个字段，各个字段之间用空格分隔。见下面的例子：123411.1.1.0/24 1.1.2.0/24 1:5 3:3 0x11/0xff 111.1.1.1 1.1.2.2 5 3 17 2) 输出格式：第一行为五元组每个字段占用的bits数以及数据条目数，后面每两行为一个data/mask对，data/mask为16进制表示，data行最后一个数值为规则对应的结果，如1）中的第一个条规则按照T的属性可以分解成下面的输出（数值32 32 16 16 8仅仅是示例）：123456789101132 32 16 16 8 5data:0x01010100 0x01010200 0x0001 0x0003 0x11 1//data和mask对mask:0xffffff00 0xffffff00 0xffff 0xffff 0xffdata:0x01010100 0x01010200 0x0002 0x0003 0x11 1mask:0xffffff00 0xffffff00 0xffff 0xffff 0xffdata:0x01010100 0x01010200 0x0003 0x0003 0x11 1mask:0xffffff00 0xffffff00 0xffff 0xffff 0xffdata:0x01010100 0x01010200 0x0004 0x0003 0x11 1mask:0xffffff00 0xffffff00 0xffff 0xffff 0xffdata:0x01010100 0x01010200 0x0005 0x0003 0x111 1mask:0xffffff00 0xffffff00 0xffff 0xffff 0xff 3) 每个报文分类的结果输出到标准输出。如1）中报文1.1.1.1 1.1.2.2 5 3 17得到下面的匹配结果：1因为： 报文目的IP 1.1.1.1前24bits跟规则中目的IP前24bits相同； 报文源IP 1.1.2.2前24bits跟规则中源IP前24bits相同； 报文目的端口5在规则中目的端口1到5的范围内； 报文源端口3在规则中源端口3到3的范围内； 协议17跟规则中协议0x11相等。实际分类是使用data、mask对进行匹配，报文能跟2）中第5个data、mask对匹配上，取其结果是1。最终输出内容如下：12345678910111232 32 16 16 8 5data:0x01010100 0x01010200 0x0001 0x0003 0x11 1mask:0xffffff00 0xffffff00 0xffff 0xffff 0xffdata:0x01010100 0x01010200 0x0002 0x0003 0x11 1mask:0xffffff00 0xffffff00 0xffff 0xffff 0xffdata:0x01010100 0x01010200 0x0003 0x0003 0x11 1mask:0xffffff00 0xffffff00 0xffff 0xffff 0xffdata:0x01010100 0x01010200 0x0004 0x0003 0x11 1mask:0xffffff00 0xffffff00 0xffff 0xffff 0xffdata:0x01010100 0x01010200 0x0005 0x0003 0x111 1mask:0xffffff00 0xffffff00 0xffff 0xffff 0xff1 算法思路程序使用c语言，首先从标准输入函数scanf中读取规则条数，然后根据条数读取规则存储在结构体中，再读取报文数，读取报文存入结构体，最后生成规则T对，再进行报文分类。使用标准输出printf输出结果。输出规则五元组占用bits数位：32 32 16 16 8 5匹配方式为：data &amp; mask = pit &amp; mask IP地址前缀匹配IP地址的匹配采用赛题规则中的前缀匹配完成，将规则进行处理，使用前缀生成掩码mask，不关心的bit置0，需要匹配的bit置1，data保持不变。最终将data和mask通过16进制打印出来。示例：读取规则：11.16.36.14/16 123.218.82.240/25 1:1 1:1 0x1e/0xff 15 生成的规则：12data:0x110240e 0x7bda52f0 0x1 0x1 0x1e 15mask:0xffff0000 0xffffff80 0xffff 0xffff 0xff 端口范围匹配由于端口范围为0-65536，所以使用16bit来表示T对。1、 利用T属性的不关心位 * 来优化容量。如端口为1-5，二进制码为：1234500010010001101000101 故4和5可优化为一个T对：12340 1 0 0（data）1 1 1 0（mask）---------------0 1 0 *（result） 同理，2和3也可优化为一个T对。核心思想：在读取规则时，得到端口起点MIN和终点MAX，将其转换为代表其值的二进制字符串。1、 从终点值MAX的字符串开始，从二进制的低位开始将为1的bit置为0（该数一定会比MAX小），置0后的数为data，mask在MAX置0的bit及高位都为1，置0之后的低位都为0。若data不为0则循环执行该规则，若data为0，说明MAX的最高位1和MIN的最高位1不在一个位置，则开始执行下一规则。① data &gt; MIN，则此T对有效。循环执行该规则；② data = MIN，则data = MIN，mask在MAX置0的bit及高位都为1，低位都为0，返回该最后一个有效T对，结束该规则；③ data &lt; MIN，则从此bit开始，循环将MIN的二进制位中有0的bit置为1，此bit之后的低位也置为0，该值赋给data，mask在MIN置1的bit及高位都为1，置1之后的低位都为0，生成一个有效的T对。当到MIN的最低位时，若该bit为1，则data = MIN，mask为0xffff，返回该最后一个有效T对，结束该规则；2、 在MAX的低位往高位不断将1置0的过程中，若已经到达MAX的最高位1时仍然大于MIN（此时MAX只有一个高位1，其他位全为0），此时不断将MAX中的高位1向右移位，生成data，mask在data中为1的bit及高位都为1，之后的低位都置为0。若data不为0则循环执行该规则直到结束。① data &gt; MIN，则此T对有效。循环执行该规则；② data = MIN，则返回该最后一个有效T对，结束该规则；③ data &lt; MIN，则从此bit开始，循环将MIN的二进制位中有0的bit置为1，此bit之后的低位也置为0，该值赋给data，mask在MIN置1的bit及高位都为1，置1之后的低位都为0，若此时data &lt; MAX则生成一个有效的T对。当到MIN的最低位时，若该bit为1，则data = MIN，mask为0xffff，返回该最后一个有效T对，结束该规则；说明：当存在某些特殊情况时，例MIN = 0，或者MAX的低位连续为1，或MAX – MIN = 1，或MAX与MIN低位连续相同且为1时，跳出以上规则进行特殊优化处理，大大缩减T对容量。示例：读取规则：11.16.36.0/24 123.218.82.0/24 0:65535 1:1 0x1e/0xff 15 生成的规则：12332 32 16 16 8 1data:0x1102400 0x7bda5200 0x0 0x1 0x1e 15mask:0xffffff00 0xffffff00 0x0 0xffff 0xff 读取规则：11.16.36.0/24 123.218.82.0/24 98:99 1:1 0x1e/0xff 15 生成的规则：12332 32 16 16 8 1data:0x1102400 0x7bda5200 0x62 0x1 0x1e 15mask:0xffffff00 0xffffff00 0xfffe 0xffff 0xff 读取规则：11.16.36.0/24 123.218.82.0/24 7:127 1:1 0x1e/0xff 15 生成的规则：123456789101132 32 16 16 8 5data:0x1102400 0x7bda5200 0x40 0x1 0x1e 15mask:0xffffff00 0xffffff00 0xffc0 0xffff 0xffdata:0x1102400 0x7bda5200 0x20 0x1 0x1e 15mask:0xffffff00 0xffffff00 0xffe0 0xffff 0xffdata:0x1102400 0x7bda5200 0x10 0x1 0x1e 15mask:0xffffff00 0xffffff00 0xfff0 0xffff 0xffdata:0x1102400 0x7bda5200 0x8 0x1 0x1e 15mask:0xffffff00 0xffffff00 0xfff8 0xffff 0xffdata:0x1102400 0x7bda5200 0x7 0x1 0x1e 15mask:0xffffff00 0xffffff00 0xffff 0xffff 0xff 读取规则：11.16.36.0/24 123.218.82.0/24 50014:59051 1:1 0x1e/0xff 15 生成的规则：1234567891011121314151617181920212223242532 32 16 16 8 12data:0x1102400 0x7bda5200 0xe6a8 0x1 0x1e 15mask:0xffffff00 0xffffff00 0xfffc 0xffff 0xffdata:0x1102400 0x7bda5200 0xe6a0 0x1 0x1e 15mask:0xffffff00 0xffffff00 0xfff8 0xffff 0xffdata:0x1102400 0x7bda5200 0xe680 0x1 0x1e 15mask:0xffffff00 0xffffff00 0xffe0 0xffff 0xffdata:0x1102400 0x7bda5200 0xe600 0x1 0x1e 15mask:0xffffff00 0xffffff00 0xff80 0xffff 0xffdata:0x1102400 0x7bda5200 0xe400 0x1 0x1e 15mask:0xffffff00 0xffffff00 0xfe00 0xffff 0xffdata:0x1102400 0x7bda5200 0xe000 0x1 0x1e 15mask:0xffffff00 0xffffff00 0xfc00 0xffff 0xffdata:0x1102400 0x7bda5200 0xd000 0x1 0x1e 15mask:0xffffff00 0xffffff00 0xf000 0xffff 0xffdata:0x1102400 0x7bda5200 0xc800 0x1 0x1e 15mask:0xffffff00 0xffffff00 0xf800 0xffff 0xffdata:0x1102400 0x7bda5200 0xc400 0x1 0x1e 15mask:0xffffff00 0xffffff00 0xfc00 0xffff 0xffdata:0x1102400 0x7bda5200 0xc380 0x1 0x1e 15mask:0xffffff00 0xffffff00 0xff80 0xffff 0xffdata:0x1102400 0x7bda5200 0xc360 0x1 0x1e 15mask:0xffffff00 0xffffff00 0xffe0 0xffff 0xffdata:0x1102400 0x7bda5200 0xc35e 0x1 0x1e 15mask:0xffffff00 0xffffff00 0xfffe 0xffff 0xff 协议精确匹配协议匹配的掩码为0xff，每一位都关心，为精确匹配，在报文分类的匹配过程中，只需判定协议是否相等即可。 源码算法通过c实现，期间想过使用格雷码（数字汉明距离均为1）和卡洛图的方式进行编码，在一定情况下确实能够进一步优化T对容量，但是优化空间并不大，所以我就没有修改了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct RowStr&#123; unsigned int IP_objA; unsigned int IP_objB; unsigned int IP_objC; unsigned int IP_objD; unsigned int IP_obj_prefix; unsigned int IP_sourceA; unsigned int IP_sourceB; unsigned int IP_sourceC; unsigned int IP_sourceD; unsigned int IP_source_prefix; unsigned int Com_objA; unsigned int Com_objB; unsigned int Com_sourceA; unsigned int Com_sourceB; unsigned int DealA; unsigned int DealB; unsigned int result;&#125;;struct Message&#123; unsigned int IP_objA; unsigned int IP_objB; unsigned int IP_objC; unsigned int IP_objD; unsigned int IP_sourceA; unsigned int IP_sourceB; unsigned int IP_sourceC; unsigned int IP_sourceD; unsigned int Com_obj; unsigned int Com_source; unsigned int Deal;&#125;;struct IPmask&#123; unsigned int IP_objAMask; unsigned int IP_objBMask; unsigned int IP_objCMask; unsigned int IP_objDMask; unsigned int IP_sourceAMask; unsigned int IP_sourceBMask; unsigned int IP_sourceCMask; unsigned int IP_sourceDMask;&#125;;struct COMresult&#123; unsigned int Com_objData[35]; unsigned int Com_objMask[35]; unsigned int Com_sourceData[35]; unsigned int Com_sourceMask[35]; unsigned int T_pair_obj; unsigned int T_pair_source;&#125;;struct RowStr RowData[512];struct Message Datagram[100];struct IPmask MaskIP[512];struct COMresult MaskCom[512];unsigned int RowNum, MesNum, maini = 0, mainj = 0, mainm = 0, maink = 0, Ti = 0, T_pairnum = 0, onenum = 0, Find = 0;const char Binstr[17][5] = &#123;&quot;0000&quot;, &quot;0001&quot;, &quot;0010&quot;, &quot;0011&quot;, &quot;0100&quot;, &quot;0101&quot;, &quot;0110&quot;, &quot;0111&quot;, &quot;1000&quot;, &quot;1001&quot;, &quot;1010&quot;, &quot;1011&quot;, &quot;1100&quot;, &quot;1101&quot;, &quot;1110&quot;, &quot;1111&quot;&#125;;void OUT_MASKIP(int n);void OUT_DATAIP(int n);void DecToBinstr(unsigned int Dec, char *s);unsigned int BinstrToDec(char *s);int OUT_DATAMASK_COM(unsigned int MAX, unsigned int MIN, unsigned int data[], unsigned int mask[]);int main()&#123; scanf(&quot;%d&quot;, &amp;RowNum); maini = 0; mainj = RowNum; while(mainj--) &#123; scanf(&quot;%d.%d.%d.%d/%d %d.%d.%d.%d/%d %d:%d %d:%d %x/%x %d&quot;, &amp;RowData[maini].IP_objA, &amp;RowData[maini].IP_objB, &amp;RowData[maini].IP_objC, &amp;RowData[maini].IP_objD, &amp;RowData[maini].IP_obj_prefix, &amp;RowData[maini].IP_sourceA, &amp;RowData[maini].IP_sourceB, &amp;RowData[maini].IP_sourceC, &amp;RowData[maini].IP_sourceD, &amp;RowData[maini].IP_source_prefix, &amp;RowData[maini].Com_objA, &amp;RowData[maini].Com_objB, &amp;RowData[maini].Com_sourceA, &amp;RowData[maini].Com_sourceB, &amp;RowData[maini].DealA, &amp;RowData[maini].DealB, &amp;RowData[maini].result); maini++; &#125; scanf(&quot;%d&quot;, &amp;MesNum); maini = 0; mainj = MesNum; while(mainj--) &#123; scanf(&quot;%d.%d.%d.%d %d.%d.%d.%d %d %d %d&quot;, &amp;Datagram[maini].IP_objA, &amp;Datagram[maini].IP_objB, &amp;Datagram[maini].IP_objC, &amp;Datagram[maini].IP_objD, &amp;Datagram[maini].IP_sourceA, &amp;Datagram[maini].IP_sourceB, &amp;Datagram[maini].IP_sourceC, &amp;Datagram[maini].IP_sourceD, &amp;Datagram[maini].Com_obj, &amp;Datagram[maini].Com_source, &amp;Datagram[maini].Deal); maini++; &#125; for(maini = 0; maini &lt; RowNum; maini++) &#123; MaskCom[maini].T_pair_obj = OUT_DATAMASK_COM(RowData[maini].Com_objB, RowData[maini].Com_objA, MaskCom[maini].Com_objData, MaskCom[maini].Com_objMask); MaskCom[maini].T_pair_source = OUT_DATAMASK_COM(RowData[maini].Com_sourceB, RowData[maini].Com_sourceA, MaskCom[maini].Com_sourceData, MaskCom[maini].Com_sourceMask); &#125; for(maini = 0; maini &lt; RowNum; maini++) &#123; onenum = MaskCom[maini].T_pair_obj * MaskCom[maini].T_pair_source; T_pairnum = T_pairnum + onenum; &#125; printf(&quot;32 32 16 16 8 %d\n&quot;, T_pairnum); for(maini = 0; maini &lt; RowNum; maini++) &#123; for(mainj = 0; mainj &lt; MaskCom[maini].T_pair_obj; mainj++) &#123; OUT_MASKIP(maini); for(mainm = 0; mainm &lt; MaskCom[maini].T_pair_source; mainm++) &#123; OUT_DATAIP(maini); printf(&quot; 0x%x 0x%x 0x%x %d\n&quot;, MaskCom[maini].Com_objData[mainj], MaskCom[maini].Com_sourceData[mainm], RowData[maini].DealA, RowData[maini].result); if(MaskIP[maini].IP_objAMask == 0) printf(&quot;mask:0x%x0%x0%x0%x0&quot;, MaskIP[maini].IP_objAMask, MaskIP[maini].IP_objBMask, MaskIP[maini].IP_objCMask, MaskIP[maini].IP_objDMask); else if(MaskIP[maini].IP_objBMask == 0) printf(&quot;mask:0x%x%x0%x0%x0&quot;, MaskIP[maini].IP_objAMask, MaskIP[maini].IP_objBMask, MaskIP[maini].IP_objCMask, MaskIP[maini].IP_objDMask); else if(MaskIP[maini].IP_objCMask == 0) printf(&quot;mask:0x%x%x%x0%x0&quot;, MaskIP[maini].IP_objAMask, MaskIP[maini].IP_objBMask, MaskIP[maini].IP_objCMask, MaskIP[maini].IP_objDMask); else if(MaskIP[maini].IP_objDMask == 0) printf(&quot;mask:0x%x%x%x%x0&quot;, MaskIP[maini].IP_objAMask, MaskIP[maini].IP_objBMask, MaskIP[maini].IP_objCMask, MaskIP[maini].IP_objDMask); else printf(&quot;mask:0x%x%x%x%x&quot;, MaskIP[maini].IP_objAMask, MaskIP[maini].IP_objBMask, MaskIP[maini].IP_objCMask, MaskIP[maini].IP_objDMask); if(MaskIP[maini].IP_sourceAMask == 0) printf(&quot; 0x%x0%x0%x0%x0&quot;, MaskIP[maini].IP_sourceAMask, MaskIP[maini].IP_sourceBMask, MaskIP[maini].IP_sourceCMask, MaskIP[maini].IP_sourceDMask); else if(MaskIP[maini].IP_sourceBMask == 0) printf(&quot; 0x%x%x0%x0%x0&quot;, MaskIP[maini].IP_sourceAMask, MaskIP[maini].IP_sourceBMask, MaskIP[maini].IP_sourceCMask, MaskIP[maini].IP_sourceDMask); else if(MaskIP[maini].IP_sourceCMask == 0) printf(&quot; 0x%x%x%x0%x0&quot;, MaskIP[maini].IP_sourceAMask, MaskIP[maini].IP_sourceBMask, MaskIP[maini].IP_sourceCMask, MaskIP[maini].IP_sourceDMask); else if(MaskIP[maini].IP_sourceDMask == 0) printf(&quot; 0x%x%x%x%x0&quot;, MaskIP[maini].IP_sourceAMask, MaskIP[maini].IP_sourceBMask, MaskIP[maini].IP_sourceCMask, MaskIP[maini].IP_sourceDMask); else printf(&quot; 0x%x%x%x%x&quot;, MaskIP[maini].IP_sourceAMask, MaskIP[maini].IP_sourceBMask, MaskIP[maini].IP_sourceCMask, MaskIP[maini].IP_sourceDMask); printf(&quot; 0x%x 0x%x 0x%x\n&quot;, MaskCom[maini].Com_objMask[mainj], MaskCom[maini].Com_sourceMask[mainm], RowData[maini].DealB); &#125; &#125; &#125; maini = 0; while(maini &lt; MesNum) &#123; Find = 0; for(mainj = 0; mainj &lt; RowNum; mainj++) &#123; if(((Datagram[maini].IP_objA &amp; MaskIP[mainj].IP_objAMask) == (RowData[mainj].IP_objA &amp; MaskIP[mainj].IP_objAMask)) &amp;&amp; ((Datagram[maini].IP_objB &amp; MaskIP[mainj].IP_objBMask) == (RowData[mainj].IP_objB &amp; MaskIP[mainj].IP_objBMask)) &amp;&amp; ((Datagram[maini].IP_objC &amp; MaskIP[mainj].IP_objCMask) == (RowData[mainj].IP_objC &amp; MaskIP[mainj].IP_objCMask)) &amp;&amp; ((Datagram[maini].IP_objD &amp; MaskIP[mainj].IP_objDMask) == (RowData[mainj].IP_objD &amp; MaskIP[mainj].IP_objDMask)) &amp;&amp; ((Datagram[maini].IP_sourceA &amp; MaskIP[mainj].IP_sourceAMask) == (RowData[mainj].IP_sourceA &amp; MaskIP[mainj].IP_sourceAMask)) &amp;&amp; ((Datagram[maini].IP_sourceB &amp; MaskIP[mainj].IP_sourceBMask) == (RowData[mainj].IP_sourceB &amp; MaskIP[mainj].IP_sourceBMask)) &amp;&amp; ((Datagram[maini].IP_sourceC &amp; MaskIP[mainj].IP_sourceCMask) == (RowData[mainj].IP_sourceC &amp; MaskIP[mainj].IP_sourceCMask)) &amp;&amp; ((Datagram[maini].IP_sourceD &amp; MaskIP[mainj].IP_sourceDMask) == (RowData[mainj].IP_sourceD &amp; MaskIP[mainj].IP_sourceDMask))) &#123; for(mainm = 0; mainm &lt; MaskCom[mainj].T_pair_obj; mainm++) &#123; if((Datagram[maini].Com_obj &amp; MaskCom[mainj].Com_objMask[mainm]) == (MaskCom[mainj].Com_objData[mainm] &amp; MaskCom[mainj].Com_objMask[mainm])) &#123; for(maink = 0; maink &lt; MaskCom[mainj].T_pair_source; maink++) &#123; if((Datagram[maini].Com_source &amp; MaskCom[mainj].Com_sourceMask[maink]) == (MaskCom[mainj].Com_sourceData[maink] &amp; MaskCom[mainj].Com_sourceMask[maink])) &#123; if((Datagram[maini].Deal &amp; RowData[mainj].DealB) == (RowData[mainj].DealA &amp; RowData[mainj].DealB)) &#123; printf(&quot;%d\n&quot;, RowData[mainj].result); Find = 1; goto LOOP; &#125; &#125; &#125; &#125; &#125; &#125; &#125; if(Find == 0) printf(&quot;0\n&quot;); LOOP:maini++; &#125; printf(&quot;32 32 16 16 8 %d\n&quot;, T_pairnum); return 0;&#125;void OUT_MASKIP(int n)&#123; int i = 0, num = 0, remainder = 0; unsigned int ip_mask = 0x00000000; num = RowData[n].IP_obj_prefix / 4; remainder = RowData[n].IP_obj_prefix % 4; for(i = 0; i &lt; 8; i++) &#123; ip_mask = ip_mask &lt;&lt; 4; if(i &lt; num) ip_mask = ip_mask + 0xf; else if(i == num) &#123; switch(remainder)&#123; case 1: ip_mask = ip_mask + 0x8; break; case 2: ip_mask = ip_mask + 0xc; break; case 3: ip_mask = ip_mask + 0xe; break; default: ip_mask = ip_mask + 0x0; &#125; &#125; &#125; MaskIP[n].IP_objAMask = ip_mask &gt;&gt; 24; MaskIP[n].IP_objBMask = (ip_mask &amp; 0xff0000) &gt;&gt; 16; MaskIP[n].IP_objCMask = (ip_mask &amp; 0xff00) &gt;&gt; 8; MaskIP[n].IP_objDMask = (ip_mask &amp; 0xff); ip_mask = 0x00000000; num = RowData[n].IP_source_prefix / 4; remainder = RowData[n].IP_source_prefix % 4; for(i = 0; i &lt; 8; i++) &#123; ip_mask = ip_mask &lt;&lt; 4; if(i &lt; num) ip_mask = ip_mask + 0xf; else if(i == num) &#123; switch(remainder)&#123; case 1: ip_mask = ip_mask + 0x8; break; case 2: ip_mask = ip_mask + 0xc; break; case 3: ip_mask = ip_mask + 0xe; break; default: ip_mask = ip_mask + 0x0; &#125; &#125; &#125; MaskIP[n].IP_sourceAMask = ip_mask &gt;&gt; 24; MaskIP[n].IP_sourceBMask = (ip_mask &amp; 0xff0000) &gt;&gt; 16; MaskIP[n].IP_sourceCMask = (ip_mask &amp; 0xff00) &gt;&gt; 8; MaskIP[n].IP_sourceDMask = (ip_mask &amp; 0xff);&#125;void OUT_DATAIP(int n)&#123; printf(&quot;data:0x%x&quot;, RowData[n].IP_objA); // if(RowData[n].IP_objB &lt; 16) // printf(&quot;0&quot;); printf(&quot;%02x&quot;, RowData[n].IP_objB); // if(RowData[n].IP_objC &lt; 16) // printf(&quot;0&quot;); printf(&quot;%02x&quot;, RowData[n].IP_objC); // if(RowData[n].IP_objD &lt; 16) // printf(&quot;0&quot;); printf(&quot;%02x&quot;, RowData[n].IP_objD); printf(&quot; 0x%x&quot;, RowData[n].IP_sourceA); // if(RowData[n].IP_sourceB &lt; 16) // printf(&quot;0&quot;); printf(&quot;%02x&quot;, RowData[n].IP_sourceB); // if(RowData[n].IP_sourceC &lt; 16) // printf(&quot;0&quot;); printf(&quot;%02x&quot;, RowData[n].IP_sourceC); // if(RowData[n].IP_sourceD &lt; 16) // printf(&quot;0&quot;); printf(&quot;%02x&quot;, RowData[n].IP_sourceD);&#125;void DecToBinstr(unsigned int Dec, char *s)&#123; unsigned int Com_tempA = 0x0000, Com_tempB = 0x0000, Com_tempC = 0x0000, Com_tempD = 0x0000; Com_tempA = Dec &gt;&gt; 12; Com_tempB = (Dec &amp; 0x0f00) &gt;&gt; 8; Com_tempC = (Dec &amp; 0x00f0) &gt;&gt; 4; Com_tempD = Dec &amp; 0x000f; strcpy(s, Binstr[Com_tempA]); strcat(s, Binstr[Com_tempB]); strcat(s, Binstr[Com_tempC]); strcat(s, Binstr[Com_tempD]);&#125;unsigned int BinstrToDec(char *s)&#123; int i; unsigned int Dec = 0; char binstrA[5], binstrB[5], binstrC[5], binstrD[5]; for(i = 0; i &lt; 4; i++) binstrA[i] = s[i]; for(i = 4; i &lt; 8; i++) binstrB[i - 4] = s[i]; for(i = 8; i &lt; 12; i++) binstrC[i - 8] = s[i]; for(i = 12; i &lt; 16; i++) binstrD[i - 12] = s[i]; for(i = 0; i &lt; 16; i++) &#123; if(strncmp(binstrA, Binstr[i], 4) == 0) Dec = i; &#125; Dec = Dec &lt;&lt; 4; for(i = 0; i &lt; 16; i++) &#123; if(strncmp(binstrB, Binstr[i], 4) == 0) Dec = Dec + i; &#125; Dec = Dec &lt;&lt; 4; for(i = 0; i &lt; 16; i++) &#123; if(strncmp(binstrC, Binstr[i], 4) == 0) Dec = Dec + i; &#125; Dec = Dec &lt;&lt; 4; for(i = 0; i &lt; 16; i++) &#123; if(strncmp(binstrD, Binstr[i], 4) == 0) Dec = Dec + i; &#125; return Dec;&#125;int OUT_DATAMASK_COM(unsigned int MAX, unsigned int MIN, unsigned int data[], unsigned int mask[])&#123; int i = 0, p[17], j = 0, count = 0, a = 0, t = -1, k = 0, q[17]; char Com_MAX[17], Com_MIN[17], temp[17]; unsigned int Comtemp, masktemp = 0x0000; DecToBinstr(MAX, Com_MAX); DecToBinstr(MIN, Com_MIN); for(i = 0; i &lt; 16; i++) &#123; if(Com_MAX[i] == &apos;1&apos;) &#123; p[j++] = i; &#125; else if(Com_MAX[i] == &apos;0&apos;) &#123; t = i; &#125; if(Com_MIN[i] == &apos;1&apos;) &#123; q[k++] = i; &#125; &#125; Comtemp = MAX; count = 0; if(Comtemp == MIN) &#123; data[count] = Comtemp; mask[count] = 0xffff; return count + 1; &#125; else &#123; if(Comtemp % 2 == 0) &#123; data[count] = Comtemp; mask[count] = 0xffff; count++; &#125; else &#123; if(p[0] &lt; t || MIN == 0) &#123; for(i = 15; i &gt; t; i--) &#123; Com_MAX[i] = &apos;0&apos;; Comtemp = BinstrToDec(Com_MAX); if(Comtemp &lt; MIN) &#123; Com_MAX[i] = &apos;1&apos;; break; &#125; else if(Comtemp == MIN) &#123; masktemp = 0x0000; while(i--) &#123; masktemp = (masktemp &gt;&gt; 1) + 0x8000; &#125; data[count] = Comtemp; mask[count] = masktemp; return count + 1; &#125; &#125; &#125; else if(p[0] &gt;= t &amp;&amp; MIN != 0) &#123; for(i = 15; i &gt; p[0]; i--) &#123; Com_MAX[i] = &apos;0&apos;; Comtemp = BinstrToDec(Com_MAX); if(Comtemp &lt; MIN) &#123; Com_MAX[i] = &apos;1&apos;; break; &#125; else if(Comtemp == MIN) &#123; masktemp = 0x0000; while(i--) &#123; masktemp = (masktemp &gt;&gt; 1) + 0x8000; &#125; data[count] = Comtemp; mask[count] = masktemp; return count + 1; &#125; &#125; &#125; masktemp = 0x0000; a = i + 1; while(a--) &#123; masktemp = (masktemp &gt;&gt; 1) + 0x8000; &#125; Comtemp = BinstrToDec(Com_MAX); data[count] = Comtemp; mask[count] = masktemp; if(MIN == 0 &amp;&amp; Comtemp == 0) return count + 1; count++; &#125; j = j - (15 - t); if(j == 0) &#123; for(j = 0; j &lt; 16; j++) if(p[j] == i) break; j = j + 1; &#125; for(i = 0; Comtemp != 0; i++) &#123; j--; Com_MAX[p[j]] = &apos;0&apos;; Comtemp = BinstrToDec(Com_MAX); if(Comtemp &gt; MIN) &#123; data[count] = Comtemp; mask[count] = (0xffff &lt;&lt; (15 - p[j]) &amp; 0xffff); if(p[j] == 15) mask[count] = 0xffff &lt;&lt; 1; mask[count] = mask[count] &amp; 0xffff; count++; &#125; else if(Comtemp == MIN &amp;&amp; Comtemp != 0) &#123; data[count] = MIN; mask[count] = 0xffff &lt;&lt; (15 - p[j]); if(p[j] == 15) mask[count] = 0xffff &lt;&lt; 1; mask[count] = mask[count] &amp; 0xffff; return count + 1; &#125; else if(Comtemp &lt; MIN &amp;&amp; Comtemp != 0) &#123; masktemp = (0xffff &lt;&lt; (15 - p[j])) &amp; 0xffff; for(i = p[j] + 1; i &lt; 16; i++) &#123; strcpy(temp, Com_MIN); masktemp = (masktemp &gt;&gt; 1) + 0x8000; if(temp[i] == &apos;0&apos; &amp;&amp; i != 15) &#123; temp[i] = &apos;1&apos;; Comtemp = BinstrToDec(temp); Comtemp = Comtemp &amp; masktemp; data[count] = Comtemp; mask[count] = masktemp; count++; &#125; else if(temp[i] == &apos;0&apos; &amp;&amp; i == 15) &#123; data[count] = MIN; mask[count] = 0xfffe; return count + 1; &#125; &#125; data[count] = MIN; mask[count] = 0xffff; return count + 1; &#125; &#125; masktemp = 0x0000; Com_MAX[p[0]] = &apos;1&apos;; a = p[0] + 1; while(a--) &#123; masktemp = (masktemp &gt;&gt; 1) + 0x8000; &#125; Comtemp = BinstrToDec(Com_MAX); if(MIN == 0) &#123; data[count] = MIN; mask[count] = masktemp; return count + 1; &#125; else &#123; for(i = 0; Comtemp != 0; i++) &#123; Comtemp = Comtemp &gt;&gt; 1; masktemp = (masktemp &gt;&gt; 1) + 0x8000; if(Comtemp &gt; MIN &amp;&amp; Comtemp != 1) &#123; data[count] = Comtemp; mask[count] = masktemp; count++; &#125; else if(Comtemp == MIN &amp;&amp; Comtemp != 0) &#123; data[count] = Comtemp; mask[count] = masktemp; return count + 1; &#125; else if(Comtemp &lt; MIN &amp;&amp; Comtemp != 0) &#123; for(i = q[0] + 1; i &lt; 16; i++) &#123; strcpy(temp, Com_MIN); masktemp = (masktemp &gt;&gt; 1) + 0x8000; if(temp[i] == &apos;0&apos; &amp;&amp; i != 15) &#123; temp[i] = &apos;1&apos;; Comtemp = BinstrToDec(temp); Comtemp = Comtemp &amp; masktemp; if(Comtemp &lt; MAX) &#123; data[count] = Comtemp; mask[count] = masktemp; count++; &#125; &#125; else if(temp[i] == &apos;0&apos; &amp;&amp; i == 15) &#123; if(Comtemp &lt; MAX) &#123; data[count] = MIN; mask[count] = 0xfffe; return count + 1; &#125; &#125; else if(temp[i] == &apos;1&apos; &amp;&amp; i == 15) &#123; data[count] = MIN; mask[count] = 0xffff; return count + 1; &#125; &#125; return count; &#125; else if(Comtemp == MIN &amp;&amp; Comtemp == 0) &#123; data[count] = MIN; mask[count] = 0xfffe; return count + 1; &#125; &#125; &#125; &#125; return count + 1;&#125; 最后附上我提交的成绩最终排名结果要想进入决赛，必须在算法上有创新，祝大家在大赛中取得好名次！]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>中兴大赛</tag>
        <tag>算法大赛</tag>
        <tag>迪杰斯，报文分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客恢复]]></title>
    <url>%2F2019%2F04%2F25%2F%E5%8D%9A%E5%AE%A2%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[我们使用github搭建个人博客后，如果长期未使用，则github会收回github pages，无论我们怎么从新配置域名都无法访问http://username.github.io。 我的方法是删除项目代码库repositories，重新新建项目代码库username.github.io，然后你就可以惊喜的发现可以通过外网直接访问到http://username.github.io了。接下来就是配置SSH密钥，在GitHub账户中添加你的公钥，配置git的个人信息，再做域名映射（这些操作网上百度一大堆，我这里就不做赘述）。 完成以上操作后，将个人本地仓库中的文件通过 12hexo ghexo d 生成静态文件并部署到个人新建的代码库中，你就可以发现个人博客已经能够恢复访问了，跟之前的一模一样，当然这个操作必须是你的本地仓库保存完整的情况下。如果本地仓库已经丢失，那么可以通过之前上传到github上的代码库下载到本地，再进行恢复操作。]]></content>
      <categories>
        <category>hexo+github 博客恢复</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[delete blog]]></title>
    <url>%2F2018%2F02%2F08%2Fdelete-blog%2F</url>
    <content type="text"><![CDATA[删除仓库里面 source/_posts/要删除的博文.md 执行下面命令更新博客123hexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 注意，不能全部删除_post文件夹下的博文，不然会报错。]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Altiumdesigner-shortcuts]]></title>
    <url>%2F2018%2F02%2F06%2FAltiumdesigner-shortcuts%2F</url>
    <content type="text"><![CDATA[一、通用设置1：Alt+F5 全屏获返回全屏。2：按住鼠标滚轮 鼠标上下滑动 放大缩小，按住Ctrl 按住鼠标右键 鼠标上下滑动也放大缩小。3：T/C 交叉探针 看到寻找原理图和PCB的元件位置。4：按住鼠标右键移动鼠标实现图纸的拖动。5：Ctrl+O 打开Choose Document to Open(选择文档)对话框。6：Ctrl+F4 关闭当前文档。7：Ctrl+S 保存当前文档。8：Alt+F4或者W/T 关闭Altium Designer，W/H水平平铺，W/V垂直平铺。9：Shift+F4 平铺已打开的文档。10：Shift+F5 在活动面板和工作区间切换。11：C/C 编译当前的工程。12：C/R 重新编译当前工程。13：End 刷新屏幕。14：Home 定位中心到光标同时刷新屏幕。15：Ctrl+PgDn 调整视图以适合所有对象。16：Ctrl+Z 撤销。17：Ctrl+Y 重新执行。18：BackSpace 在放置导线、总线、直线或多边形时移除最后一个顶点。19：CTRL+SHIFT+ T 、B、L、R、H、V、D可以快速对齐所选中的元件 上 下 左 右 水平 垂直 栅格。20：Shift+C 清除高亮 二、原理图1：按住shift 拖动某个元件，可快速复制。2：Alt+左击 在图纸中高亮所有在网络的元素。4：按住Ctrl 拖动某个元件，可以移动位置，并且保持原来的线连接（在18版中，无需按住Ctrl，直接拖拽即可）。5：Ctrl+H 搜索和替换文本。6：Ctrl+F 查找文本。7：F3 搜索下一个。8：E/M/D或者按住Ctrl 鼠标点击器件完成器件的拖动（和器件连接的线也会跟着移动）。9：Insert 放置相同类型对象的时候复制对象的属性。10：P/W 画线。11：P/T 添加text。12：Shift+拖拽 复制元器件。 三、PCB1：E/S/Y 选中该层全部线条。2：D/S/D 按选择对象重新定义板子形状。3：Shift+鼠标点击 实现多选。4：Shift+S 键 切换单层显示。5：Q 英寸和毫米 尺寸切换。6：D+R 进入布线规则设置。7：Ctrl+鼠标单击某个线，整个线的NET 网络 呈现高亮状态。8：Ctrl+H+鼠标单击某个线，整个线的NET网络被选中。9：小键盘上的 * （星号键）可以在top、bottom layer切换达到快速切换上下层。另外 + - 可以把所有显示的层轮流切换。10：U+选NET 点布线删除NET之间的布线11：M+I 可以把选中所有的元件，翻转过来。这样可以在上下层切换，方便布线，调整印丝层。12：鼠标点击器件选中，左键按住不放+L可以快速将该器件翻转到另一层。13：器件联合，选中两个器件，然后右击 选择 联合（unions）-从选中的器件生成联合（Create Union from selected objects）这样可以操作两个位置在一起的器件，当要去掉时候 选中器件 右击 联合-从联合打散器件 那么连接在一起的就能够单独操作了。当选中联合的器件，右击选择联合，有个 选择所有的联合 这样一下子选择所有联合的器件。固定的外框就可以联合起来移动操作。14：多根线同时画的时候，每个先画个短的线，按SHIFT 选中所有一起画的线，选好，松开SHIFT，鼠标移动到线头 白点处，然后拖动，那么所有线就一起拖动。 转弯一次，松开， 在拖，又可以转弯。15: E/D 删线16: Shift+E 捕捉焊盘开关17：Ctrl+M或者R/M 测量任意两点之间的距离18：L或者O/M 打开图层显示控制界面19：P+G 快速打开敷铜设置20：画线时Ctrl+Shift+Space 在5种线形之间切换21：Shift+B 建立查询22：Ctrl 走线时按下来暂时禁用电气栅格23：T/E 添加或删除泪滴24：P/P 放置焊盘25：P/V 放置过孔26：P/T 画线27：P/D/L 测量尺寸28：Shift+A 调用蛇形走线，再按 1和2改变转角，按 3和4改变间距，按，和。改变宽窄29：Space空格键 在交互布线的过程中，切换布线方向。这很常用。30：主键盘上的1 在交互布线的过程中，切换布线方法（设定每次单击鼠标布1段线还是2段线）。31：主键盘上的2 在交互布线的过程中，添加一个过孔，但不换层。32：J/L 定位到指定的坐标的位置。这时要注意确认左下角的坐标值，如果定位不准，可以放大视图并重新定位，如果还是不准，则需要修改栅格吸附尺寸。（定位坐标应该为吸附尺寸的整数倍）。33：J/C 定位到指定的元件处。在弹出的对话框内输入该元件的编号。34：画线时按住Ctrl+Shift然后滑动滚轮可切换层画线并自动添加过孔。35：Shift+F 查找相似对象。36：R/I/E 生成元件清单。37：T/O 选择打散器件方式。 四、其他InPolygon 设置敷铜和走线、过孔、焊盘之间的间距InNet（‘’）指定网络IsVia 过孔IsPad 焊盘]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>Altiumdesigner</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyinstall的使用]]></title>
    <url>%2F2018%2F01%2F31%2Fpyinstall%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在python文件目录下命令行输入（若文件为test.py）：1pyinstaller -F test.py //参数-F 表示生成单个exe文件 执行后在该目录下会生成一个dist目录，test.exe文件存放在dist目录下。 如果运行的是GUI类型的程序，你不想弹出命令窗口，可以采用：1pyinstaller -F -w test.py 打包exe时，定制程序图标可以使用以下命令：1pyinstaller -F -w -i lincn.ico test.py 其中lincn.ico为你希望定制的程序图标。 当你的py文件引入了多个py，进行程序打包时，将引入的py名称放在主py文件之后即可。 其他pyinstaller指令如图：]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github write blog]]></title>
    <url>%2F2018%2F01%2F30%2Fhexo-github-write-blog%2F</url>
    <content type="text"><![CDATA[一、创建博客定位到我们的hexo根目录，执行命令：$ hexo new [layout] &quot;title&quot;即可新建一个博文页面。 布局（layout） 存储路径 说明 post source/posts 默认，可以直接发布 page source 在source下新建一个文件夹 drft source/drafts 新建文件将保存到_drafts中 可以用publish命令将草稿移动到source/posts文件夹下$ hexo publish [layout] &lt;title&gt; 二、写博客1、博文目录格式打开hexo/source/posts目录下的md文件，即可进行博客编写。打开Markdown文件，其格式为：1234567title: hexo-blog #文章标题date: 2018-01-30 15:51:07 #创作时间tags: [标签1, 标签2, 标签3] #标签categories: hexo github #分类description: 这是一篇教你怎么发布博文的文章 #文章描述---以下是正文 默认情况下，生成的博文目录会显示全部的内容，如何设置文章摘要的长度呢？答案就是在合适的位置加上&lt;!--more--&gt;注意如果博文含有description项目，则在博文目录中会优先显示该项的内容。 2、文字斜体和粗体及分割线在博文中文字斜体和粗体的写法：1234*这是斜体*或_这也是斜体_**这是粗体*****这是加粗斜体***~~这是删除线~~ 效果：这是斜体 或 这也是斜体这是粗体这是加粗斜体这是删除线 分割线的语法只需要三个星号*或者三个小短线-号 效果： 3、分级标题标题是每篇文章最常用的格式，在Markdown语法中，如果某行文字被定义为标题，只需要在行首加上#符号即可：1234# 一级标题## 二级标题### 三级标题... 几级标题就用几个#符号，总共有六级标题，注意每级标题#符号后面的空格要加上。 4、无序列表无序列表的三种写法：123* 无序列表项1+ 无序列表项2- 无序列表项3 效果： 无序列表项1 无序列表项2 无序列表项3 5、绘制表格表格的写法：12345| 表头1|表头2|表头3|表头4|-| :- | :-: | -: ||默认左对齐|左对齐|居中对其|右对齐||默认左对齐|左对齐|居中对其|右对齐||默认左对齐|左对齐|居中对其|右对齐| 效果: 表头1 表头2 表头3 表头4 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 注意：表格前后要换行。 6、外链接在博文中插入一些外链接的写法：12345行内形式：[我的博客](http://www.lincnwang.tech/)参考形式：[我的博客][1]，我的学校-[成都信息工程大学][2][1]:http://www.lincnwang.tech/[2]:http://www.cuit.edu.cn/自动链接：我的博客地址&lt;http://www.lincnwang.tech/&gt; 效果：行内形式：我的博客参考形式：我的博客，我的学校-成都信息工程大学 自动链接：我的博客地址http://www.lincnwang.tech/ 7、文本注释在写博文的过程中，我们常常需要对某部分进行注释或者引入某段代码，此时我们需要用到文本的注释功能。代码区域内的文字不会被处理，按照原样输出。 ①引入代码第一种：引入单行代码出现一个代码框，需要使用反单引号（电脑Esc键下面的键）夹在需要注释的文本两侧。例如：1`hellow lincnwang` 效果：hellow lincnwang 第二种：多行代码的引入需要在代码段的前后分别使用三个反单引号。 例如：1234if (a &lt; b)&#123; a=b;&#125; ②引入内容第一种：通过在文字开头添加”&gt;”表示注释,例如： 优秀是一种习惯！ 第二种：或者每一行前边加入四个空格或者一个tab可以标记一个段落。例如： 成都信息工程大学 优秀是一种习惯 8、转义字符Markdown中的转义字符为\，可以转义的有：123456789101112\\ 反斜杠\` 反引号\* 星号\_ 下划线\&#123;\&#125; 大括号\[\] 中括号\(\) 小括号\# 井号\+ 加号\- 减号\. 英文句号\! 感叹号 9、插入图片在hexo中插入图片，首先需要将图片放在source/images/文件夹下或者source/_posts/(博客名文件夹)，然后如下方式进行插入：1![“图片描述”](/images/你的图片名字.JPG) 例如：1![测试图片](hexo-github-write-blog/one.jpg) 效果： 10、引入公式例如：123$$a=b+c$$ 效果：$$a=b+c$$ 三、发布博文 hexo g（完整指令为hexo generate），用于生成静态文件。 hexo s（完成指令为hexo server），用于启动服务器，主要用来本地浏览在浏览器输入：localhost:4000,就可以进行访问，发布到网络博客地址可略过这一步。 hexo d（完整指令为hexo deploy），用于将本地文件发布到github等git仓库上。发布完成之后即可登录博客进行浏览。]]></content>
      <categories>
        <category>hexo+github 写博客</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python tkinter的使用]]></title>
    <url>%2F2017%2F12%2F27%2Fpython-tkinter%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[master = Tk()master.title(“度云物联网异或校验工具”)data_dir = “data”]]></content>
      <categories>
        <category>GUI设计</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于带通采样定理的高速数据采集系统的硬件电路设计]]></title>
    <url>%2F2017%2F12%2F13%2FpostLincnwang-%E4%BD%A0%E5%A5%BD%2F</url>
    <content type="text"><![CDATA[摘要: 介绍了带通采样定理，它在数据采集中可以降低采样率，但是在实际采集中存在信号混叠，采样“盲区”和频谱反转等问题，对这些问题提出了解决方法。在这个理论基础上，设计了高速数据采集系统的硬件电路，介绍了数据采集ADC 芯片 AD08D1000，以及该芯片的外围差分信号转换电路和时钟信号产生电路，同时还介绍了电源模块电路和用于数据传输的 USB 模块电路。关键词: 带通采样; 数据采集; ADC08D1000 Hardware Circuit Design of High-speed Data Acquisition System Based on Band-pass Sampling TheoremAbstract: This paper introduced the band-pass sampling theorem. The sampling rate in data collection can be greatly reduced by this theorem. However, problems of signals aliasing, sampling blind area and spectrum reversal were appeared in actual data collection. The paper proposed the solution methods of these problems. Then the hardware circuit of the high-speed data acquisition system was designed based on the theoretical basis. The data acquisition ADC chip AD08D1000, the peripheral difference signal circuit of the chip and the clock signal circuit were introduced. Besides, the power module circuit and the USB module circuit used for data transmission were introduced.Key words: band-pass sampling; data acquisition; ADC08D1000 引言数据采集是获得信息的一种基本手段。随着信息科学技术的迅速发展，它已经成为信息领域中不可缺少的部分。随着科技的不断进步，人们对数据采集系统的要求也越来越高，不仅要求采样的精度高，数据转换速度快，还要求具有抗干扰能力。高速数据采集系统主要包括几个部分:前端调理电路，高速ADC，时钟电路，微处理器以及电源等组成。文中提出一种以NiosⅡ为核心控制器，基于带通采样的高速数据采集系统，并设计了系统中各个部分的硬件电路。 1 带通采样根据奈奎斯特采样定理，对于频带为(0，fh)的信号，要想采样后能够不失真的还原出原信号，则抽样频率必须大于2倍信号的最高频率，即fs≥2fh．但是实际中多数信号是频率很高的信号，对于频率为(fL，fH)的高频率信号，如果用fs≥2fh的采样频率进行采样，现在的ADC器件根本无法实现，且后续的数字信号处理器也无法处理高频率信号。这个时候我们可以通过在软件无线电中应用十分广泛的带通采样定理来采样。 1．1 带通采样定理理论带通采样定理:频带为(fL，fH)的带通信号，带宽B=fH－fL．如果其采样速率满足:f_x=(2(f_L+f_H))/(2n+1)=〖4f〗_0/(2n+1)式中f_0=(f_L+f_H)/2，其中n取能满足f_s=2(f_H-f_L)的整数，那么用fs进行等间隔采样得到的信号能准确的确定原信号。带通采样定理的结果把位于［nB，(n+1)B］(n=0，1，2，3……)不同频带上的信号都用位于(0，B)频带的信号来表示。所以带通采样定理所使用的前提条件是:只允许1个频带上存在信号，不允许其他不相同的频带上同时存在信号。如果其他不相同的频带上存在信号，则会引起信号混叠。这样可以采用抗混叠滤波器来解决，即在采样前先进行滤波，得到想要的带通信号，再进行采样。 1．2 带通采样中的“盲区”处理当抗混叠滤波器是理想的情况下， 通过调节滤波器的中心频率，可以采用同一采样频率f_s=2(f_H-f_L)来对整个频段的信号进行采样，这样可以实现整个频段的无“盲区”采样。但是现实中理想的滤波器是不存在的，可实现的滤波器采样的直接过后就是存在采样“盲区”，当信号落在“盲区”时， 就会被滤波器滤掉，从而无法对信号进行采样并使其数字化。解决这个采样盲区的办法是使用一个主采样频率配合多个“盲区”采样频率进行采样。根据式f_x=(2(f_L+f_H))/(2n+1)=〖4f〗_0/(2n+1)可知“盲区”采样频率:f_sm=4/(2n+1) f_om式中f_om为“盲区”采样中心频率，它与主采样频率f_s的关系为:f_om=(m+1)/2 f_s得:f_sm=(2m+2)/(2n+1) f_s式中m取不同整数对应的不同“盲区”，n的取值尽量使f_sm靠近f_s。 1．3带通采样中的频谱反转带通采样的结果是把位于［nB，(n+1)B］(n=0，1，2，3……)不同频带上的信号都用位于(0，B)频带的信号来表示。当n为偶数时，采样后信号的频谱在零频位置得以还原。但是当n为基数时，采样后信号的频谱在零频位置却发生了翻转。就n=3来说明，频谱为(3B，4B)的信号在采样频谱如图1所示。经过采样频率fs=2B采样后信号的频谱如图2所示，可以看出采样后信号频谱在零频位置(－B，B)上发生了反转，而在(－2B，0)和(0，2B)上信号频谱没有发生反转。在这段频率上信号x(t)的频域表达式为X(w±2πB)，将其进行时域变换得到:X(w±2πB)→e^(±j2πBt) x(t)＝e^(±jπf_s t) x(t)进行离散变换，得到数字化序列为:e^(±jπn) x(n)=(-1)^n x(n)从式中看出，只要将数字化序列进行隔位符号取反，就可以解决n为基数时的频谱反转问题。]]></content>
      <categories>
        <category>硬件设计</category>
      </categories>
      <tags>
        <tag>hardware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello]]></title>
    <url>%2F2017%2F12%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Lincnwang’s blog! This is my very first post. If you have any problems when read my article, please feel free to leave a message or contact with me, I wish make friend with you. And share something with you! HardWareSoftWare]]></content>
      <categories>
        <category>交流</category>
      </categories>
  </entry>
</search>
